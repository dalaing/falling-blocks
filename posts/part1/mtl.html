<!DOCTYPE html> 
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Dave Laing - Adding `mtl`</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="../../css/custom.css">
        <link rel="stylesheet" href="../../css/syntax.css">
        <link rel="alternate" type="application/atom+xml" title="Atom - Falling Blocks" href="../../atom.xml" />
        <link rel="alternate" type="application/rss+xml" title="RSS - Falling Blocks" href="../../rss.xml" />
    </head>
    <body>
        <nav class="navbar navbar-default navbar-static-top">
        <div class="container">
        <div class="navbar-header">
            <div class="navbar-brand">
                <a href="../../">Falling Blocks</a>
            </div>
            <ul class="nav navbar-nav">
                <li role="presentation"><a href="http://dlaing.org">Back to my main site</a></li>
            </ul>
        </div>

        </div>
        </nav>

        <div class="container">
            <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title"><a href="../../posts/part1/mtl.html">Adding `mtl`</a></h3>
    </div>
    <div class="panel-body">
        <h1 id="introduction">Introduction</h1>
<p><a href="./cycle.html">Previously</a> we expanded on the example from <code>sdl2</code>.</p>
<p>In this post we’ll be adding monad transformers to the code.</p>
<p>We’re doing this to reduce the cost of change for the code, as well as to remove the need to manually plumb configuration and state through our code. For now the reduced plumbing will be the most obvious benefit.</p>
<p>The code is available <a href="https://github.com/dalaing/falling-blocks/tree/master/code/part1/mtl">here</a>.</p>
<h2 id="what-you-need-to-know-about-monad-transformers-and-mtl-for-now">What you need to know about monad transformers and <code>mtl</code> for now</h2>
<h3 id="effects">Effects</h3>
<p>In this post we’ll be working with <code>Reader</code>, <code>State</code> and <code>IO</code> effects.</p>
<p>I’m assuming there’s a good chance that you’re familiar with these. If you’re not familiar with <code>IO</code>, you should probably read a bit more about monads and <code>IO</code> and come back later.</p>
<p>The <code>Reader</code> effect is for passing configuration information around. We can use <code>ReaderT</code> to do this while other effects are in play.</p>
<p>We can go from this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foo, must,<span class="ot"> die ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()

foo x <span class="fu">=</span> <span class="kw">do</span>
  must x
  die x</code></pre></div>
<p>to this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foo, must,<span class="ot"> die ::</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> <span class="dt">IO</span> ()

foo <span class="fu">=</span> <span class="kw">do</span>
  must
  die</code></pre></div>
<p>If we need to access to the configuration, we can use <code>ask</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ask ::</span> <span class="dt">ReaderT</span> r m <span class="ot">-&gt;</span> m r</code></pre></div>
<p>like so:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">must ::</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> <span class="dt">IO</span> ()
must <span class="fu">=</span> <span class="kw">do</span>
  <span class="fu">...</span>
  c <span class="ot">&lt;-</span> ask
  putStrLn c
  <span class="fu">...</span></code></pre></div>
<p>As we use the configuration in more places and inside functions with more levels of nesting, we increase the amount of plumbing that gets saved.</p>
<p>We use <code>runReaderT</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runReaderT ::</span> <span class="dt">ReaderT</span> r m a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> m a</code></pre></div>
<p>to actually make use of this, which in this case would work something like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runReaderT foo<span class="ot"> exampleConfig ::</span> <span class="dt">IO</span> ()</code></pre></div>
<p>The <code>State</code> effect is for threading state through computations, and there is also a <code>StateT</code> for when other effects are in play.</p>
<p>We can go from this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foo, must,<span class="ot"> die ::</span> <span class="dt">MyState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">MyState</span>

foo s <span class="fu">=</span> <span class="kw">do</span>
  s' <span class="ot">&lt;-</span> must s
  s'' <span class="ot">&lt;-</span> die s'
  return s''</code></pre></div>
<p>to this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foo, must,<span class="ot"> die ::</span> <span class="dt">StateT</span> <span class="dt">MyState</span> <span class="dt">IO</span> ()

foo <span class="fu">=</span> <span class="kw">do</span>
  must
  die</code></pre></div>
<p>We can use <code>get</code>, <code>put</code> and <code>modify</code> to work with the <code>State</code> while we’re working inside <code>State</code> or <code>StateT</code>.</p>
<p>Instead of <code>runReaderT</code> we have <code>runStateT</code>, <code>evalStateT</code> and <code>execStateT</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runStateT ::</span> <span class="dt">StateT</span> s m a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m (a, s)
<span class="ot">evalStateT ::</span> <span class="dt">StateT</span> s m a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m a
<span class="ot">execStateT ::</span> <span class="dt">StateT</span> s m a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m s</code></pre></div>
<p>depending on what we want as output.</p>
<h3 id="combining-effects">Combining effects</h3>
<p>Monad transformers allow us to combine effects.</p>
<p>We’ll mostly be dealing with:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">ReaderT</span> <span class="dt">Renderer</span> (<span class="dt">StateT</span> <span class="dt">GameState</span> <span class="dt">IO</span>) a</code></pre></div>
<p>The order matters for monad transformers, so this is a different type than:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">StateT</span> <span class="dt">GameState</span> (<span class="dt">ReaderT</span> <span class="dt">Renderer</span> <span class="dt">IO</span>) a</code></pre></div>
<p>but it won’t effect us too much.</p>
<p>The monad transformers themselves have <code>Monad</code> instances:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">StateT</span> m)
<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ReaderT</span> m)</code></pre></div>
<p>which is what allows us to use them with do-notation.</p>
<p>There are 3 effects in these monad transformer stacks, and we can work with these effects via a number of typeclasses provided by <code>mtl</code>:</p>
<ul>
<li><code>MonadReader r m</code> lets us work with <code>Reader</code> effects</li>
<li><code>MonadState s m</code> lets us work with <code>State</code> effects</li>
<li><code>MonadIO m</code> lets us work with <code>IO</code> effects</li>
</ul>
<p>These will work no matter where the effect is in our stack, or what other effects are in the stack.</p>
<p>I like that a great deal, since it means I can get some code written quickly and nail down the details of the stack later on.</p>
<p>That should be enough to get started, so let us dig in.</p>
<h2 id="updating-the-event-handling">Updating the event handling</h2>
<p>First we will update <code>gatherEvents</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherEvents ::</span> <span class="dt">IO</span> [<span class="dt">AppEvent</span>]</code></pre></div>
<p>This is managing <code>IO</code> effects, soe can bring the <code>IO</code> into an <code>mtl</code> style typeclass constraint with <code>MonadIO m</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherEvents ::</span> <span class="dt">MonadIO</span> m
         <span class="ot">=&gt;</span> m [<span class="dt">AppEvent</span>]</code></pre></div>
<p>To do this we will use <code>liftIO</code>, which lifts a concrete <code>IO</code> action to the more abstract <code>MonadIO m</code> action:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">liftIO ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a</code></pre></div>
<p>to move from</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherEvents ::</span> <span class="dt">IO</span> [<span class="dt">AppEvent</span>]
gatherEvents <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- gather the pending SDL events</span>
  es <span class="ot">&lt;-</span> pollEvents
  <span class="co">-- add an 'AppRender' event to the front of the list</span>
  return <span class="fu">$</span> <span class="dt">AppRender</span> <span class="fu">:</span> fmap toAppEvent es</code></pre></div>
<p>to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherEvents ::</span> <span class="dt">MonadIO</span> m
             <span class="ot">=&gt;</span> m [<span class="dt">AppEvent</span>]
gatherEvents <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- gather the pending SDL events</span>
  es <span class="ot">&lt;-</span> liftIO pollEvents
  <span class="co">-- add an 'AppRender' event to the front of the list</span>
  return <span class="fu">$</span> <span class="dt">AppRender</span> <span class="fu">:</span> fmap toAppEvent es</code></pre></div>
<h2 id="updating-the-rendering">Updating the rendering</h2>
<p>We start with what we have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> <span class="dt">Renderer</span>
           <span class="ot">-&gt;</span> <span class="dt">GameState</span>
           <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
background r s <span class="fu">=</span> <span class="kw">do</span>
  rendererDrawColor r <span class="fu">$=</span> (toSDLColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> s)
  clear r

<span class="ot">render ::</span> <span class="dt">Renderer</span>
       <span class="ot">-&gt;</span> <span class="dt">GameState</span>
       <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
render r s <span class="fu">=</span> <span class="kw">do</span>
  background r s
  present r</code></pre></div>
<p>and then we use <code>liftIO</code> to move from <code>IO</code> to <code>MonadIO m</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> <span class="dt">MonadIO</span> m
           <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
           <span class="ot">-&gt;</span> <span class="dt">GameState</span>
           <span class="ot">-&gt;</span> m ()
background r s <span class="fu">=</span> liftIO <span class="fu">$</span> <span class="kw">do</span>
  rendererDrawColor r <span class="fu">$=</span> (toSDLColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> s)
  clear r

<span class="ot">render ::</span> <span class="dt">MonadIO</span> m
       <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
       <span class="ot">-&gt;</span> <span class="dt">GameState</span>
       <span class="ot">-&gt;</span> m ()
render r s <span class="fu">=</span> liftIO <span class="fu">$</span> <span class="kw">do</span>
  background r s
  present r</code></pre></div>
<p>Since the <code>GameState</code> will be operating in the <code>State</code> monad elsewhere, we bring the passing of the <code>GameState</code> through these functions into play with the <code>MonadState GameState m</code> constraint, to move from</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">background,<span class="ot"> render ::</span> <span class="dt">MonadIO</span> m
                   <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
                   <span class="ot">-&gt;</span> <span class="dt">GameState</span>
                   <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">background,<span class="ot"> render ::</span> (<span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
                   <span class="ot">-&gt;</span> <span class="dt">Renderer</span>
                   <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>We can use <code>gets</code> to access the game state:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gets ::</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> m a </code></pre></div>
<p>Specialized to <code>GameState</code> we have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gets ::</span> <span class="dt">MonadState</span> <span class="dt">GameState</span> m <span class="ot">=&gt;</span> (<span class="dt">GameState</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> m a </code></pre></div>
<p>Adding the <code>backgroundColour</code> accessor function in:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">backgroundColour ::</span> <span class="dt">GameState</span> <span class="ot">-&gt;</span> <span class="dt">Colour</span></code></pre></div>
<p>we get</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gets<span class="ot"> backgroundColur ::</span> <span class="dt">MonadState</span> <span class="dt">GameState</span> m <span class="ot">=&gt;</span> m <span class="dt">Colour</span></code></pre></div>
<p>and we can even add <code>toSDLColour</code> in to get to the data we need:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gets (toSDLColour <span class="fu">.</span> backgroundColur)<span class="ot"> ::</span> <span class="dt">MonadState</span> <span class="dt">GameState</span> m <span class="ot">=&gt;</span> m (<span class="dt">V4</span> <span class="dt">Word8</span>)</code></pre></div>
<p>The version using <code>MonadState GameState m</code> is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> (<span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
           <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
           <span class="ot">-&gt;</span> m ()
background r <span class="fu">=</span> <span class="kw">do</span>
  c <span class="ot">&lt;-</span> gets <span class="fu">$</span> toSDLColour <span class="fu">.</span> backgroundColour
  liftIO <span class="fu">$</span> <span class="kw">do</span>
    rendererDrawColor r <span class="fu">$=</span> (toSDLColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> s)
    clear r
     
<span class="ot">render ::</span> (<span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m
       <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
       <span class="ot">-&gt;</span> m ()
render r <span class="fu">=</span> liftIO <span class="fu">$</span> <span class="kw">do</span>
  background r
  present r</code></pre></div>
<p>We can save some plumbing of the <code>Renderer</code> in the surrounding code by introducing <code>MonadReader Renderer m</code>.</p>
<p>This changes the types from</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">background,<span class="ot"> render ::</span> (<span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
                   <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
                   <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">background,<span class="ot"> render ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
                   <span class="ot">=&gt;</span> m ()</code></pre></div>
<p>We will then use <code>ask</code> to get the <code>Renderer</code> whenever we need it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ask ::</span> <span class="dt">MonadReader</span> r m <span class="ot">-&gt;</span> m r</code></pre></div>
<p>which specializes to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ask ::</span> <span class="dt">MonadReader</span> <span class="dt">Renderer</span> m <span class="ot">-&gt;</span> m <span class="dt">Renderer</span></code></pre></div>
<p>The version using <code>MonadReader Renderer m</code> is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
           <span class="ot">=&gt;</span> m ()
background <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> ask
  c <span class="ot">&lt;-</span> gets <span class="fu">$</span> toSDLColour <span class="fu">.</span> backgroundColour
  liftIO <span class="fu">$</span> <span class="kw">do</span>
    rendererDrawColor r <span class="fu">$=</span> c
    clear r

<span class="ot">render ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
       <span class="ot">=&gt;</span> m ()
render <span class="fu">=</span> <span class="kw">do</span>
  background
  r <span class="ot">&lt;-</span> ask
  liftIO <span class="fu">$</span>
    present r</code></pre></div>
<p>If we wound up drawing something completely independent of the <code>GameState</code>, we’d have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">stateless ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadIO</span> m)
          <span class="ot">=&gt;</span> m ()</code></pre></div>
<p>In general, we don’t add constraints that we aren’t going to use. This makes it easier to reason about the what a function (and the functions it may call) can or cannot do.</p>
<p>While we’re reasoning about code, we know that <code>stateless</code> can’t modify the <code>GameState</code>. While we’re refactoring code, we are prevented from accidentally modifying the <code>GameState</code> either directly or indirectly, because the compiler will stop us.</p>
<h2 id="updating-the-main-loop">Updating the main loop</h2>
<p>We will update the type signature of <code>gameStep</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> <span class="dt">Renderer</span>
         <span class="ot">-&gt;</span> <span class="dt">AppEvent</span>
         <span class="ot">-&gt;</span> <span class="dt">GameState</span> 
         <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">GameState</span></code></pre></div>
<p>so that the handling of the <code>IO</code> effects is more abstract:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> <span class="dt">MonadIO</span> m
         <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
         <span class="ot">-&gt;</span> <span class="dt">AppEvent</span>
         <span class="ot">-&gt;</span> <span class="dt">GameState</span> 
         <span class="ot">-&gt;</span> m <span class="dt">GameState</span></code></pre></div>
<p>and the state handling is done by the <code>State</code> monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> (<span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
         <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
         <span class="ot">-&gt;</span> <span class="dt">AppEvent</span>
         <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>and the passing through of the configuration data is done by the <code>Reader</code> monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
         <span class="ot">=&gt;</span> <span class="dt">AppEvent</span>
         <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>The changes to each of the cases in the function are minor.</p>
<p>We start with this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> <span class="dt">Renderer</span>
         <span class="ot">-&gt;</span> <span class="dt">AppEvent</span>
         <span class="ot">-&gt;</span> <span class="dt">GameState</span> 
         <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">GameState</span>
gameStep r <span class="dt">AppRender</span> gs <span class="fu">=</span> <span class="kw">do</span>
  render r gs
  return gs
gameStep _ <span class="dt">AppCycle</span> gs <span class="fu">=</span> 
  return <span class="fu">$</span> gs { backgroundColour <span class="fu">=</span> nextColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> gs }
gameStep _ <span class="dt">AppQuit</span> gs <span class="fu">=</span> 
  return <span class="fu">$</span> gs { hasQuit <span class="fu">=</span> <span class="dt">True</span> }
gameStep _ _ gs <span class="fu">=</span> 
  return gs</code></pre></div>
<p>We no longer need to thread the <code>Renderer</code> and <code>GameState</code> through to the call to <code>render</code>, so</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gameStep r <span class="dt">AppRender</span> gs <span class="fu">=</span> <span class="kw">do</span>
  render r gs
  return gs</code></pre></div>
<p>becomes</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gameStep <span class="dt">AppRender</span> <span class="fu">=</span>
  render</code></pre></div>
<p>The default case has an even simpler change, from</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gameStep _ _ gs <span class="fu">=</span> 
  return gs</code></pre></div>
<p>to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gameStep _ <span class="fu">=</span>
  return ()</code></pre></div>
<p>This leaves the two cases that involve updating the state using a function of type <code>GameState -&gt; GameState</code>.</p>
<p>That is exactly what <code>modify</code> does:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">modify ::</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>so we use that to go from</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gameStep _ <span class="dt">AppCycle</span> gs <span class="fu">=</span> 
  return <span class="fu">$</span> gs { backgroundColour <span class="fu">=</span> nextColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> gs }
gameStep _ <span class="dt">AppQuit</span> gs <span class="fu">=</span> 
  return <span class="fu">$</span> gs { hasQuit <span class="fu">=</span> <span class="dt">True</span> }</code></pre></div>
<p>to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gameStep <span class="dt">AppCycle</span> <span class="fu">=</span>
  modify <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs { backgroundColour <span class="fu">=</span> nextColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> gs }
gameStep <span class="dt">AppQuit</span> <span class="fu">=</span>
  modify <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs { hasQuit <span class="fu">=</span> <span class="dt">True</span> }</code></pre></div>
<p>The final result is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
         <span class="ot">=&gt;</span> <span class="dt">AppEvent</span> 
         <span class="ot">-&gt;</span> m ()
gameStep <span class="dt">AppRender</span> <span class="fu">=</span>
  render
gameStep <span class="dt">AppCycle</span> <span class="fu">=</span>
  modify <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs { backgroundColour <span class="fu">=</span> nextColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> gs }
gameStep <span class="dt">AppQuit</span> <span class="fu">=</span>
  modify <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs { hasQuit <span class="fu">=</span> <span class="dt">True</span> }
gameStep _ <span class="fu">=</span>
  return ()</code></pre></div>
<p>The update to the main loop involves removing the plumbing of the <code>Renderer</code> and <code>GameState</code> through everything and the addition of the various typeclass constraints that we’ve picked up along the way.</p>
<p>For the previous version we used <code>gameStep</code> as part of a fold over the list of <code>AppEvent</code>s we got from a call to <code>gatherEvents</code>.</p>
<p>We now need to deal with the new <code>gameStep</code>, which operates with <code>MonadReader Renderer m</code>, <code>MonadState GameState m</code> and <code>MonadIO m</code> in the context.</p>
<p>We can use <code>traverse_</code> from <code>Data.Foldable</code> in the <code>base</code> package to do this.</p>
<p>The type signature is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">traverse_ ::</span> (<span class="dt">Foldable</span> t, <span class="dt">Applicative</span> f)
          <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b)
          <span class="ot">-&gt;</span> t a
          <span class="ot">-&gt;</span> f ()</code></pre></div>
<p>There is a <code>Foldable</code> instance for <code>List</code>, so we can specialize to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">traverse_ ::</span> <span class="dt">Applicative</span> f
          <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b)
          <span class="ot">-&gt;</span> [a]
          <span class="ot">-&gt;</span> f ()</code></pre></div>
<p>We can partly specialize the <code>Applicative</code> constraint. With <code>MonadReader Renderer m</code>, <code>MonadState GameState m</code> and <code>MonadIO m</code> in context, <code>m</code> is a <code>Monad</code>, and every <code>Monad</code> is an <code>Applicative</code>.</p>
<p>This gives us:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">traverse_ ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
          <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b)
          <span class="ot">-&gt;</span> [a]
          <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>If we use <code>AppEvent</code> for <code>a</code> and <code>()</code> for <code>b</code> we get as far as we can for <code>traverse_</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">traverse_ ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
          <span class="ot">=&gt;</span> (<span class="dt">AppEvent</span> <span class="ot">-&gt;</span> m ())
          <span class="ot">-&gt;</span> [<span class="dt">AppEvent</span>]
          <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>We already have a function with the right type for the first argument:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
         <span class="ot">=&gt;</span> <span class="dt">AppEvent</span> 
         <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>which gives us</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">traverse_<span class="ot"> gameStep ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
                   <span class="ot">=&gt;</span> [<span class="dt">AppEvent</span>]
                   <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>which is just what we need to handle the output from <code>gatherEvents</code>.</p>
<p>The <code>gameLoop</code> function also need to access the <code>hasQuit</code> field of the <code>GameState</code>.</p>
<p>We can use <code>gets</code> again for this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gets<span class="ot"> hasQuit ::</span> <span class="dt">MonadState</span> <span class="dt">GameState</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> </code></pre></div>
<p>We go from this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameLoop ::</span> <span class="dt">Renderer</span>
         <span class="ot">-&gt;</span> <span class="dt">GameState</span>
         <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
gameLoop r s <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- gather the events</span>
  es <span class="ot">&lt;-</span> gatherEvents
  <span class="co">-- interpret the events</span>
  s' <span class="ot">&lt;-</span> foldrM (gameStep r) s es
  <span class="co">-- check to see if the user has quit</span>
  <span class="kw">let</span> q <span class="fu">=</span> hasQuit s'
  <span class="co">-- if not, keep going</span>
  unless q (gameLoop r s')</code></pre></div>
<p>to this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameLoop ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
         <span class="ot">=&gt;</span> m ()
gameLoop <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- gather the events</span>
  es <span class="ot">&lt;-</span> gatherEvents
  <span class="co">-- interpret the events</span>
  traverse_ gameStep es
  <span class="co">-- check to see if the user has quit</span>
  q <span class="ot">&lt;-</span> gets hasQuit
  <span class="co">-- if not, keep going</span>
  unless q gameLoop</code></pre></div>
<p>We also add a function to set up and kick off the monad transformers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">startGameLoop ::</span> <span class="dt">Renderer</span> <span class="ot">-&gt;</span> <span class="dt">GameState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
startGameLoop r s <span class="fu">=</span> evalStateT (runReaderT gameLoop r) s</code></pre></div>
<h2 id="updating-main">Updating <code>main</code></h2>
<p>If you’ve been browsing through the source code you’ll notice that most of the code is in a library, and the <code>main</code> function is part of a module that uses that library to build an executable.</p>
<p>By supplying <code>startGameLoop</code> the <code>main</code> function doesn’t need to know about anything <code>mtl</code> related. The executable doesn’t directly depend on the <code>mtl</code> package in that case. That doesn’t buy us much, but it’s nice to know that <code>mtl</code> is just an implementation detail from the perspective of the executable.</p>
<p>Our old <code>main</code> function looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  initialize [<span class="dt">InitEverything</span>]
  window <span class="ot">&lt;-</span> createWindow <span class="st">&quot;My SDL Application&quot;</span> defaultWindow
  r <span class="ot">&lt;-</span> createRenderer window (<span class="fu">-</span><span class="dv">1</span>) defaultRenderer
  gameLoop r defaultGameState</code></pre></div>
<p>and the new version looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  initialize [<span class="dt">InitEverything</span>]
  window <span class="ot">&lt;-</span> createWindow <span class="st">&quot;My SDL Application&quot;</span> defaultWindow
  r <span class="ot">&lt;-</span> createRenderer window (<span class="fu">-</span><span class="dv">1</span>) defaultRenderer
  startGameLoop r defaultGameState</code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>We’ve mostly swapped plumbing for typeclass constraints, although we’re getting into a better position to make further changes.</p>
<p><a href="./lens.html">Next</a> we’ll bring <code>lens</code> into the mix, and will also look at how mixing <code>mtl</code> and <code>lens</code> can provide some additional benefits.</p>
    </div>
    
    <div class="panel-footer">
        <h5>Posted on September 14, 2015 </h5>
    </div>
    
</div>

            <div class="row">
                <div class="col-md-5"> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> </div>
                <div class="col-md-7">
                    This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
                    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
                </div>
            </div>
        </div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59162164-1', 'auto');
  ga('send', 'pageview');
</script>

    </body>
</html>
