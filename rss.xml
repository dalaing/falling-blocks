<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Falling blocks</title>
        <link>http://dlaing.org/falling-blocks</link>
        <description><![CDATA[]]></description>
        <atom:link href="http://dlaing.org/falling-blocks/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Tue, 15 Sep 2015 02:00:00 UT</lastBuildDate>
        <item>
    <title>Driving the updates with a timer</title>
    <link>http://dlaing.org/falling-blocks/posts/part1/timer.html</link>
    <description><![CDATA[]]></description>
    <pubDate>Tue, 15 Sep 2015 02:00:00 UT</pubDate>
    <guid>http://dlaing.org/falling-blocks/posts/part1/timer.html</guid>
    <dc:creator>Dave Laing</dc:creator>
</item>
<item>
    <title>Breaking up the initial example</title>
    <link>http://dlaing.org/falling-blocks/posts/part1/refactor.html</link>
    <description><![CDATA[<h1 id="the-sdl2-example">The <code>sdl2</code> example</h1>
<p>The <code>sdl2</code> packages comes with the following example</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">SDL</span>
<span class="kw">import </span><span class="dt">Linear</span>
<span class="kw">import </span><span class="dt">Control.Monad</span> (unless)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  initialize [<span class="dt">InitEverything</span>]
  window <span class="ot">&lt;-</span> createWindow <span class="st">&quot;My SDL Application&quot;</span> defaultWindow
  renderer <span class="ot">&lt;-</span> createRenderer window (<span class="fu">-</span><span class="dv">1</span>) defaultRenderer
  appLoop renderer

<span class="ot">appLoop ::</span> <span class="dt">Renderer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
appLoop renderer <span class="fu">=</span> <span class="kw">do</span>
  events <span class="ot">&lt;-</span> pollEvents
  <span class="kw">let</span> eventIsQPress event <span class="fu">=</span>
        <span class="kw">case</span> eventPayload event <span class="kw">of</span>
          <span class="dt">KeyboardEvent</span> keyboardEvent <span class="ot">-&gt;</span>
            keyboardEventKeyMotion keyboardEvent <span class="fu">==</span> <span class="dt">Pressed</span> <span class="fu">&amp;&amp;</span>
            keysymKeycode (keyboardEventKeysym keyboardEvent) <span class="fu">==</span> <span class="dt">KeycodeQ</span>
          _ <span class="ot">-&gt;</span> <span class="dt">False</span>
      qPressed <span class="fu">=</span> not (null (filter eventIsQPress events))
  rendererDrawColor renderer <span class="fu">$=</span> <span class="dt">V4</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">255</span> <span class="dv">255</span>
  clear renderer
  present renderer
  unless qPressed (appLoop renderer)</code></pre></div>
<h1 id="refactoring">Refactoring</h1>
<p>We can refactor this to prepare a little for what we’re about to do later on.</p>
<p>This will happen in a number of stages, and will look like <em>massive</em> over-engineering.</p>
<p>I’m heading down that path because:</p>
<ul>
<li>it will make future changes easier</li>
<li>I’ve already put in the time to learn these techniques, so the cost for using these techniques is quite reasonable for me</li>
</ul>
<p>I’m hoping that this series helps motivate some people to dig further into learning the various initially-daunting-looking tools. Not everyone will want to spend the time or think that the value of the tools is worth the time, but that’s fine.</p>
<p>Everyone else can strap in and come for a ride.</p>
<p>For now we’re going to separate out</p>
<ul>
<li>the game state</li>
<li>the event handling</li>
<li>the rendering</li>
</ul>
<p>so that we have something pretty close to a model-view-controller design.</p>
<p>The code is available <a href="https://github.com/dalaing/falling-blocks/tree/master/code/part1/refactor">here</a>.</p>
<h2 id="the-game-state">The game state</h2>
<p>The game state is pretty simple at this point. We just need to track whether or not we have quit.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">GameState</span> <span class="fu">=</span> <span class="dt">GameState</span> {
<span class="ot">    hasQuit ::</span> <span class="dt">Bool</span> 
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>We also add a default <code>GameState</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">defaultGameState ::</span> <span class="dt">GameState</span>
defaultGameState <span class="fu">=</span> <span class="dt">GameState</span> <span class="dt">False</span></code></pre></div>
<h2 id="our-own-event-type">Our own event type</h2>
<p>We set up our own even type so that we can be explicit about the information that is important to us:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AppEvent</span> <span class="fu">=</span>
    <span class="dt">AppRender</span>
  <span class="fu">|</span> <span class="dt">AppQuit</span>
  <span class="fu">|</span> <span class="dt">AppOther</span> <span class="dt">Event</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>The only event that we will be reacting to is <code>AppQuit</code>.</p>
<p>We will be adding a synthetic <code>AppRender</code> event into the mix so that we can drive all of our behaviour from a stream of <code>AppEvent</code>s. The hope is that this will give us better separation of concerns and that it will make testing easier.</p>
<p>We have <code>AppOther</code> in there as a catch-all.</p>
<p>It’s easy to repurpose the code from the example into code to convert from SDL events to <code>AppEvent</code>s:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toAppEvent ::</span> <span class="dt">Event</span>
           <span class="ot">-&gt;</span> <span class="dt">AppEvent</span>
toAppEvent event <span class="fu">=</span>
  <span class="kw">case</span> eventPayload event <span class="kw">of</span>
      <span class="dt">KeyboardEvent</span> keyboardEvent <span class="ot">-&gt;</span>
        <span class="kw">if</span> keyboardEventKeyMotion keyboardEvent <span class="fu">==</span> <span class="dt">Pressed</span>
        <span class="kw">then</span>
          <span class="kw">case</span> keysymKeycode (keyboardEventKeysym keyboardEvent) <span class="kw">of</span>
              <span class="dt">KeycodeQ</span> <span class="ot">-&gt;</span> <span class="dt">AppQuit</span>
              _ <span class="ot">-&gt;</span> <span class="dt">AppOther</span> event
        <span class="kw">else</span>
          <span class="dt">AppOther</span> event
      _ <span class="ot">-&gt;</span> <span class="dt">AppOther</span> event</code></pre></div>
<p>We can now write our interface to the SDL event system. This will gather the pending SDL events and convert them to <code>AppEvent</code> values.</p>
<p>It will also inject an <code>AppRender</code> event into the head of the event stream. We do this because we want to start by rendering, rather than displaying an empty frame until SDL events arrive.</p>
<p>This is what we end up with:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherEvents ::</span> <span class="dt">IO</span> [<span class="dt">AppEvent</span>]
gatherEvents <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- gather the pending SDL events</span>
  es <span class="ot">&lt;-</span> pollEvents
  <span class="co">-- add an &#39;AppRender&#39; event to the front of the list</span>
  return <span class="fu">$</span> <span class="dt">AppRender</span> <span class="fu">:</span> fmap toAppEvent es</code></pre></div>
<p>At this point, we have an interface to the event system that - aside from <code>AppOther</code> - is independent of the fact that we’re using SDL.</p>
<h2 id="rendering-the-game-state">Rendering the game state</h2>
<p>We’d also like the SDL specific parts of the rendering to be hidden away from the higher level interactions with that code. We’re going to aim for a central <code>render</code> function to do this.</p>
<p>We create a main function to do our rendering, which will call all the other rendering functions and then call <code>present</code> to update the screen.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">render ::</span> <span class="dt">Renderer</span>
     <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
render r <span class="fu">=</span> <span class="kw">do</span>
  background r
  present r</code></pre></div>
<p>For now all we have to display is the background:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> <span class="dt">Renderer</span>
           <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
background r <span class="fu">=</span> <span class="kw">do</span>
  rendererDrawColor r <span class="fu">$=</span> <span class="dt">V4</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">255</span> <span class="dv">255</span>
  clear r</code></pre></div>
<p>but later on we’ll have drawing functions to render the relevant information from our game state.</p>
<p>The interface still exposes the fact that we need a <code>Renderer</code>, so we don’t have as nice a separation of concerns as we do with the event handling. This will improve in future posts as we bring more abstraction into play.</p>
<h2 id="tying-it-all-together">Tying it all together</h2>
<p>We need something that will tie together the game state, the events and the rendering.</p>
<p>Since we’re trying to drive this thing by events, we’ll start by writing a function to process a single event:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> <span class="dt">Renderer</span> 
         <span class="ot">-&gt;</span> <span class="dt">AppEvent</span> 
         <span class="ot">-&gt;</span> <span class="dt">GameState</span> 
         <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">GameState</span>
gameStep r <span class="dt">AppRender</span> gs <span class="fu">=</span> <span class="kw">do</span>
  render r
  return gs
gameStep _ <span class="dt">AppQuit</span> gs <span class="fu">=</span>
  return <span class="fu">$</span> gs { hasQuit <span class="fu">=</span> <span class="dt">True</span> }
gameStep _ _ gs <span class="fu">=</span>
  return gs</code></pre></div>
<p>To use it, we need to gather the pending events, process them all with a fold, and then keep going until the user quits:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameLoop ::</span> <span class="dt">Renderer</span>
         <span class="ot">-&gt;</span> <span class="dt">GameState</span>
         <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
gameLoop r s <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- gather the events</span>
  es <span class="ot">&lt;-</span> gatherEvents
  <span class="co">-- interpret the events</span>
  s&#39; <span class="ot">&lt;-</span> foldrM (gameStep r) s es
  <span class="co">-- check to see if the user has quit</span>
  <span class="kw">let</span> q <span class="fu">=</span> hasQuit s&#39;
  <span class="co">-- if not, keep going</span>
  unless q (gameLoop r s&#39;)</code></pre></div>
<p>The last thing to do is to modify the <code>main</code> function so that our initial state gets passed to the game loop:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  initialize [<span class="dt">InitEverything</span>]
  window <span class="ot">&lt;-</span> createWindow <span class="st">&quot;My SDL Application&quot;</span> defaultWindow
  r <span class="ot">&lt;-</span> createRenderer window (<span class="fu">-</span><span class="dv">1</span>) defaultRenderer
  gameLoop r defaultGameState</code></pre></div>
<p>And we’re done.</p>
<h1 id="conclusion">Conclusion</h1>
<p>We’ve exploded the code, the event handling code and the rendering code are separated by the code that deals with the game state.</p>
<p>We still have lots more to do, but it’s a good first step.</p>
<p><a href="./cycle.html">Next</a> we’ll add a little more functionality, in order to be able to better demonstrate some of the tools and techniques we’ll be using.</p>]]></description>
    <pubDate>Mon, 14 Sep 2015 02:00:00 UT</pubDate>
    <guid>http://dlaing.org/falling-blocks/posts/part1/refactor.html</guid>
    <dc:creator>Dave Laing</dc:creator>
</item>
<item>
    <title>Adding `mtl`</title>
    <link>http://dlaing.org/falling-blocks/posts/part1/mtl.html</link>
    <description><![CDATA[<h1 id="introduction">Introduction</h1>
<p><a href="./cycle.html">Previously</a> we expanded on the example from <code>sdl2</code>.</p>
<p>In this post we’ll be adding monad transformers to the code.</p>
<p>We’re doing this to reduce the cost of change for the code, as well as to remove the need to manually plumb configuration and state through our code. For now the reduced plumbing will be the most obvious benefit.</p>
<p>The code is available <a href="https://github.com/dalaing/falling-blocks/tree/master/code/part1/mtl">here</a>.</p>
<h2 id="what-you-need-to-know-about-monad-transformers-and-mtl-for-now">What you need to know about monad transformers and <code>mtl</code> for now</h2>
<h3 id="effects">Effects</h3>
<p>In this post we’ll be working with <code>Reader</code>, <code>State</code> and <code>IO</code> effects.</p>
<p>I’m assuming there’s a good chance that you’re familiar with these. If you’re not familiar with <code>IO</code>, you should probably read a bit more about monads and <code>IO</code> and come back later.</p>
<p>The <code>Reader</code> effect is for passing configuration information around. We can use <code>ReaderT</code> to do this while other effects are in play.</p>
<p>We can go from this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foo, must,<span class="ot"> die ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()

foo x <span class="fu">=</span> <span class="kw">do</span>
  must x
  die x</code></pre></div>
<p>to this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foo, must,<span class="ot"> die ::</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> <span class="dt">IO</span> ()

foo <span class="fu">=</span> <span class="kw">do</span>
  must
  die</code></pre></div>
<p>If we need to access to the configuration, we can use <code>ask</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ask ::</span> <span class="dt">ReaderT</span> r m <span class="ot">-&gt;</span> m r</code></pre></div>
<p>like so:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">must ::</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> <span class="dt">IO</span> ()
must <span class="fu">=</span> <span class="kw">do</span>
  <span class="fu">...</span>
  c <span class="ot">&lt;-</span> ask
  putStrLn c
  <span class="fu">...</span></code></pre></div>
<p>As we use the configuration in more places and inside functions with more levels of nesting, we increase the amount of plumbing that gets saved.</p>
<p>We use <code>runReaderT</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runReaderT ::</span> <span class="dt">ReaderT</span> r m a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> m a</code></pre></div>
<p>to actually make use of this, which in this case would work something like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runReaderT foo<span class="ot"> exampleConfig ::</span> <span class="dt">IO</span> ()</code></pre></div>
<p>The <code>State</code> effect is for threading state through computations, and there is also a <code>StateT</code> for when other effects are in play.</p>
<p>We can go from this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foo, must,<span class="ot"> die ::</span> <span class="dt">MyState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">MyState</span>

foo s <span class="fu">=</span> <span class="kw">do</span>
  s&#39; <span class="ot">&lt;-</span> must s
  s&#39;&#39; <span class="ot">&lt;-</span> die s&#39;
  return s&#39;&#39;</code></pre></div>
<p>to this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foo, must,<span class="ot"> die ::</span> <span class="dt">StateT</span> <span class="dt">MyState</span> <span class="dt">IO</span> ()

foo <span class="fu">=</span> <span class="kw">do</span>
  must
  die</code></pre></div>
<p>We can use <code>get</code>, <code>put</code> and <code>modify</code> to work with the <code>State</code> while we’re working inside <code>State</code> or <code>StateT</code>.</p>
<p>Instead of <code>runReaderT</code> we have <code>runStateT</code>, <code>evalStateT</code> and <code>execStateT</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runStateT ::</span> <span class="dt">StateT</span> s m a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m (a, s)
<span class="ot">evalStateT ::</span> <span class="dt">StateT</span> s m a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m a
<span class="ot">execStateT ::</span> <span class="dt">StateT</span> s m a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m s</code></pre></div>
<p>depending on what we want as output.</p>
<h3 id="combining-effects">Combining effects</h3>
<p>Monad transformers allow us to combine effects.</p>
<p>We’ll mostly be dealing with:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">ReaderT</span> <span class="dt">Renderer</span> (<span class="dt">StateT</span> <span class="dt">GameState</span> <span class="dt">IO</span>) a</code></pre></div>
<p>The order matters for monad transformers, so this is a different type than:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">StateT</span> <span class="dt">GameState</span> (<span class="dt">ReaderT</span> <span class="dt">Renderer</span> <span class="dt">IO</span>) a</code></pre></div>
<p>but it won’t effect us too much.</p>
<p>The monad transformers themselves have <code>Monad</code> instances:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">StateT</span> m)
<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ReaderT</span> m)</code></pre></div>
<p>which is what allows us to use them with do-notation.</p>
<p>There are 3 effects in these monad transformer stacks, and we can work with these effects via a number of typeclasses provided by <code>mtl</code>:</p>
<ul>
<li><code>MonadReader r m</code> lets us work with <code>Reader</code> effects</li>
<li><code>MonadState s m</code> lets us work with <code>State</code> effects</li>
<li><code>MonadIO m</code> lets us work with <code>IO</code> effects</li>
</ul>
<p>These will work no matter where the effect is in our stack, or what other effects are in the stack.</p>
<p>I like that a great deal, since it means I can get some code written quickly and nail down the details of the stack later on.</p>
<p>That should be enough to get started, so let us dig in.</p>
<h2 id="updating-the-event-handling">Updating the event handling</h2>
<p>First we will update <code>gatherEvents</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherEvents ::</span> <span class="dt">IO</span> [<span class="dt">AppEvent</span>]</code></pre></div>
<p>This is managing <code>IO</code> effects, soe can bring the <code>IO</code> into an <code>mtl</code> style typeclass constraint with <code>MonadIO m</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherEvents ::</span> <span class="dt">MonadIO</span> m
         <span class="ot">=&gt;</span> m [<span class="dt">AppEvent</span>]</code></pre></div>
<p>To do this we will use <code>liftIO</code>, which lifts a concrete <code>IO</code> action to the more abstract <code>MonadIO m</code> action:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">liftIO ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a</code></pre></div>
<p>to move from</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherEvents ::</span> <span class="dt">IO</span> [<span class="dt">AppEvent</span>]
gatherEvents <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- gather the pending SDL events</span>
  es <span class="ot">&lt;-</span> pollEvents
  <span class="co">-- add an &#39;AppRender&#39; event to the front of the list</span>
  return <span class="fu">$</span> <span class="dt">AppRender</span> <span class="fu">:</span> fmap toAppEvent es</code></pre></div>
<p>to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherEvents ::</span> <span class="dt">MonadIO</span> m
             <span class="ot">=&gt;</span> m [<span class="dt">AppEvent</span>]
gatherEvents <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- gather the pending SDL events</span>
  es <span class="ot">&lt;-</span> liftIO pollEvents
  <span class="co">-- add an &#39;AppRender&#39; event to the front of the list</span>
  return <span class="fu">$</span> <span class="dt">AppRender</span> <span class="fu">:</span> fmap toAppEvent es</code></pre></div>
<h2 id="updating-the-rendering">Updating the rendering</h2>
<p>We start with what we have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> <span class="dt">Renderer</span>
           <span class="ot">-&gt;</span> <span class="dt">GameState</span>
           <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
background r s <span class="fu">=</span> <span class="kw">do</span>
  rendererDrawColor r <span class="fu">$=</span> (toSDLColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> s)
  clear r

<span class="ot">render ::</span> <span class="dt">Renderer</span>
       <span class="ot">-&gt;</span> <span class="dt">GameState</span>
       <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
render r s <span class="fu">=</span> <span class="kw">do</span>
  background r s
  present r</code></pre></div>
<p>and then we use <code>liftIO</code> to move from <code>IO</code> to <code>MonadIO m</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> <span class="dt">MonadIO</span> m
           <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
           <span class="ot">-&gt;</span> <span class="dt">GameState</span>
           <span class="ot">-&gt;</span> m ()
background r s <span class="fu">=</span> liftIO <span class="fu">$</span> <span class="kw">do</span>
  rendererDrawColor r <span class="fu">$=</span> (toSDLColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> s)
  clear r

<span class="ot">render ::</span> <span class="dt">MonadIO</span> m
       <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
       <span class="ot">-&gt;</span> <span class="dt">GameState</span>
       <span class="ot">-&gt;</span> m ()
render r s <span class="fu">=</span> liftIO <span class="fu">$</span> <span class="kw">do</span>
  background r s
  present r</code></pre></div>
<p>Since the <code>GameState</code> will be operating in the <code>State</code> monad elsewhere, we bring the passing of the <code>GameState</code> through these functions into play with the <code>MonadState GameState m</code> constraint, to move from</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">background,<span class="ot"> render ::</span> <span class="dt">MonadIO</span> m
                   <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
                   <span class="ot">-&gt;</span> <span class="dt">GameState</span>
                   <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">background,<span class="ot"> render ::</span> (<span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
                   <span class="ot">-&gt;</span> <span class="dt">Renderer</span>
                   <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>We can use <code>gets</code> to access the game state:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gets ::</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> m a </code></pre></div>
<p>Specialized to <code>GameState</code> we have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gets ::</span> <span class="dt">MonadState</span> <span class="dt">GameState</span> m <span class="ot">=&gt;</span> (<span class="dt">GameState</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> m a </code></pre></div>
<p>Adding the <code>backgroundColour</code> accessor function in:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">backgroundColour ::</span> <span class="dt">GameState</span> <span class="ot">-&gt;</span> <span class="dt">Colour</span></code></pre></div>
<p>we get</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gets<span class="ot"> backgroundColur ::</span> <span class="dt">MonadState</span> <span class="dt">GameState</span> m <span class="ot">=&gt;</span> m <span class="dt">Colour</span></code></pre></div>
<p>and we can even add <code>toSDLColour</code> in to get to the data we need:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gets (toSDLColour <span class="fu">.</span> backgroundColur)<span class="ot"> ::</span> <span class="dt">MonadState</span> <span class="dt">GameState</span> m <span class="ot">=&gt;</span> m (<span class="dt">V4</span> <span class="dt">Word8</span>)</code></pre></div>
<p>The version using <code>MonadState GameState m</code> is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> (<span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
           <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
           <span class="ot">-&gt;</span> m ()
background r <span class="fu">=</span> <span class="kw">do</span>
  c <span class="ot">&lt;-</span> gets <span class="fu">$</span> toSDLColour <span class="fu">.</span> backgroundColour
  liftIO <span class="fu">$</span> <span class="kw">do</span>
    rendererDrawColor r <span class="fu">$=</span> (toSDLColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> s)
    clear r
     
<span class="ot">render ::</span> (<span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m
       <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
       <span class="ot">-&gt;</span> m ()
render r <span class="fu">=</span> liftIO <span class="fu">$</span> <span class="kw">do</span>
  background r
  present r</code></pre></div>
<p>We can save some plumbing of the <code>Renderer</code> in the surrounding code by introducing <code>MonadReader Renderer m</code>.</p>
<p>This changes the types from</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">background,<span class="ot"> render ::</span> (<span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
                   <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
                   <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">background,<span class="ot"> render ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
                   <span class="ot">=&gt;</span> m ()</code></pre></div>
<p>We will then use <code>ask</code> to get the <code>Renderer</code> whenever we need it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ask ::</span> <span class="dt">MonadReader</span> r m <span class="ot">-&gt;</span> m r</code></pre></div>
<p>which specializes to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ask ::</span> <span class="dt">MonadReader</span> <span class="dt">Renderer</span> m <span class="ot">-&gt;</span> m <span class="dt">Renderer</span></code></pre></div>
<p>The version using <code>MonadReader Renderer m</code> is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
           <span class="ot">=&gt;</span> m ()
background <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> ask
  c <span class="ot">&lt;-</span> gets <span class="fu">$</span> toSDLColour <span class="fu">.</span> backgroundColour
  liftIO <span class="fu">$</span> <span class="kw">do</span>
    rendererDrawColor r <span class="fu">$=</span> c
    clear r

<span class="ot">render ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
       <span class="ot">=&gt;</span> m ()
render <span class="fu">=</span> <span class="kw">do</span>
  background
  r <span class="ot">&lt;-</span> ask
  liftIO <span class="fu">$</span>
    present r</code></pre></div>
<p>If we wound up drawing something completely independent of the <code>GameState</code>, we’d have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">stateless ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadIO</span> m)
          <span class="ot">=&gt;</span> m ()</code></pre></div>
<p>In general, we don’t add constraints that we aren’t going to use. This makes it easier to reason about the what a function (and the functions it may call) can or cannot do.</p>
<p>While we’re reasoning about code, we know that <code>stateless</code> can’t modify the <code>GameState</code>. While we’re refactoring code, we are prevented from accidentally modifying the <code>GameState</code> either directly or indirectly, because the compiler will stop us.</p>
<h2 id="updating-the-main-loop">Updating the main loop</h2>
<p>We will update the type signature of <code>gameStep</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> <span class="dt">Renderer</span>
         <span class="ot">-&gt;</span> <span class="dt">AppEvent</span>
         <span class="ot">-&gt;</span> <span class="dt">GameState</span> 
         <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">GameState</span></code></pre></div>
<p>so that the handling of the <code>IO</code> effects is more abstract:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> <span class="dt">MonadIO</span> m
         <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
         <span class="ot">-&gt;</span> <span class="dt">AppEvent</span>
         <span class="ot">-&gt;</span> <span class="dt">GameState</span> 
         <span class="ot">-&gt;</span> m <span class="dt">GameState</span></code></pre></div>
<p>and the state handling is done by the <code>State</code> monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> (<span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
         <span class="ot">=&gt;</span> <span class="dt">Renderer</span>
         <span class="ot">-&gt;</span> <span class="dt">AppEvent</span>
         <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>and the passing through of the configuration data is done by the <code>Reader</code> monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
         <span class="ot">=&gt;</span> <span class="dt">AppEvent</span>
         <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>The changes to each of the cases in the function are minor.</p>
<p>We start with this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> <span class="dt">Renderer</span>
         <span class="ot">-&gt;</span> <span class="dt">AppEvent</span>
         <span class="ot">-&gt;</span> <span class="dt">GameState</span> 
         <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">GameState</span>
gameStep r <span class="dt">AppRender</span> gs <span class="fu">=</span> <span class="kw">do</span>
  render r gs
  return gs
gameStep _ <span class="dt">AppCycle</span> gs <span class="fu">=</span> 
  return <span class="fu">$</span> gs { backgroundColour <span class="fu">=</span> nextColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> gs }
gameStep _ <span class="dt">AppQuit</span> gs <span class="fu">=</span> 
  return <span class="fu">$</span> gs { hasQuit <span class="fu">=</span> <span class="dt">True</span> }
gameStep _ _ gs <span class="fu">=</span> 
  return gs</code></pre></div>
<p>We no longer need to thread the <code>Renderer</code> and <code>GameState</code> through to the call to <code>render</code>, so</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gameStep r <span class="dt">AppRender</span> gs <span class="fu">=</span> <span class="kw">do</span>
  render r gs
  return gs</code></pre></div>
<p>becomes</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gameStep <span class="dt">AppRender</span> <span class="fu">=</span>
  render</code></pre></div>
<p>The default case has an even simpler change, from</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gameStep _ _ gs <span class="fu">=</span> 
  return gs</code></pre></div>
<p>to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gameStep _ <span class="fu">=</span>
  return ()</code></pre></div>
<p>This leaves the two cases that involve updating the state using a function of type <code>GameState -&gt; GameState</code>.</p>
<p>That is exactly what <code>modify</code> does:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">modify ::</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>so we use that to go from</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gameStep _ <span class="dt">AppCycle</span> gs <span class="fu">=</span> 
  return <span class="fu">$</span> gs { backgroundColour <span class="fu">=</span> nextColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> gs }
gameStep _ <span class="dt">AppQuit</span> gs <span class="fu">=</span> 
  return <span class="fu">$</span> gs { hasQuit <span class="fu">=</span> <span class="dt">True</span> }</code></pre></div>
<p>to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gameStep <span class="dt">AppCycle</span> <span class="fu">=</span>
  modify <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs { backgroundColour <span class="fu">=</span> nextColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> gs }
gameStep <span class="dt">AppQuit</span> <span class="fu">=</span>
  modify <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs { hasQuit <span class="fu">=</span> <span class="dt">True</span> }</code></pre></div>
<p>The final result is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
         <span class="ot">=&gt;</span> <span class="dt">AppEvent</span> 
         <span class="ot">-&gt;</span> m ()
gameStep <span class="dt">AppRender</span> <span class="fu">=</span>
  render
gameStep <span class="dt">AppCycle</span> <span class="fu">=</span>
  modify <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs { backgroundColour <span class="fu">=</span> nextColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> gs }
gameStep <span class="dt">AppQuit</span> <span class="fu">=</span>
  modify <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs { hasQuit <span class="fu">=</span> <span class="dt">True</span> }
gameStep _ <span class="fu">=</span>
  return ()</code></pre></div>
<p>The update to the main loop involves removing the plumbing of the <code>Renderer</code> and <code>GameState</code> through everything and the addition of the various typeclass constraints that we’ve picked up along the way.</p>
<p>For the previous version we used <code>gameStep</code> as part of a fold over the list of <code>AppEvent</code>s we got from a call to <code>gatherEvents</code>.</p>
<p>We now need to deal with the new <code>gameStep</code>, which operates with <code>MonadReader Renderer m</code>, <code>MonadState GameState m</code> and <code>MonadIO m</code> in the context.</p>
<p>We can use <code>traverse_</code> from <code>Data.Foldable</code> in the <code>base</code> package to do this.</p>
<p>The type signature is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">traverse_ ::</span> (<span class="dt">Foldable</span> t, <span class="dt">Applicative</span> f)
          <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b)
          <span class="ot">-&gt;</span> t a
          <span class="ot">-&gt;</span> f ()</code></pre></div>
<p>There is a <code>Foldable</code> instance for <code>List</code>, so we can specialize to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">traverse_ ::</span> <span class="dt">Applicative</span> f
          <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b)
          <span class="ot">-&gt;</span> [a]
          <span class="ot">-&gt;</span> f ()</code></pre></div>
<p>We can partly specialize the <code>Applicative</code> constraint. With <code>MonadReader Renderer m</code>, <code>MonadState GameState m</code> and <code>MonadIO m</code> in context, <code>m</code> is a <code>Monad</code>, and every <code>Monad</code> is an <code>Applicative</code>.</p>
<p>This gives us:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">traverse_ ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
          <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b)
          <span class="ot">-&gt;</span> [a]
          <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>If we use <code>AppEvent</code> for <code>a</code> and <code>()</code> for <code>b</code> we get as far as we can for <code>traverse_</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">traverse_ ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
          <span class="ot">=&gt;</span> (<span class="dt">AppEvent</span> <span class="ot">-&gt;</span> m ())
          <span class="ot">-&gt;</span> [<span class="dt">AppEvent</span>]
          <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>We already have a function with the right type for the first argument:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameStep ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
         <span class="ot">=&gt;</span> <span class="dt">AppEvent</span> 
         <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>which gives us</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">traverse_<span class="ot"> gameStep ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
                   <span class="ot">=&gt;</span> [<span class="dt">AppEvent</span>]
                   <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>which is just what we need to handle the output from <code>gatherEvents</code>.</p>
<p>The <code>gameLoop</code> function also need to access the <code>hasQuit</code> field of the <code>GameState</code>.</p>
<p>We can use <code>gets</code> again for this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gets<span class="ot"> hasQuit ::</span> <span class="dt">MonadState</span> <span class="dt">GameState</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> </code></pre></div>
<p>We go from this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameLoop ::</span> <span class="dt">Renderer</span>
         <span class="ot">-&gt;</span> <span class="dt">GameState</span>
         <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
gameLoop r s <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- gather the events</span>
  es <span class="ot">&lt;-</span> gatherEvents
  <span class="co">-- interpret the events</span>
  s&#39; <span class="ot">&lt;-</span> foldrM (gameStep r) s es
  <span class="co">-- check to see if the user has quit</span>
  <span class="kw">let</span> q <span class="fu">=</span> hasQuit s&#39;
  <span class="co">-- if not, keep going</span>
  unless q (gameLoop r s&#39;)</code></pre></div>
<p>to this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameLoop ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
         <span class="ot">=&gt;</span> m ()
gameLoop <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- gather the events</span>
  es <span class="ot">&lt;-</span> gatherEvents
  <span class="co">-- interpret the events</span>
  traverse_ gameStep es
  <span class="co">-- check to see if the user has quit</span>
  q <span class="ot">&lt;-</span> gets hasQuit
  <span class="co">-- if not, keep going</span>
  unless q gameLoop</code></pre></div>
<p>We also add a function to set up and kick off the monad transformers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">startGameLoop ::</span> <span class="dt">Renderer</span> <span class="ot">-&gt;</span> <span class="dt">GameState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
startGameLoop r s <span class="fu">=</span> evalStateT (runReaderT gameLoop r) s</code></pre></div>
<h2 id="updating-main">Updating <code>main</code></h2>
<p>If you’ve been browsing through the source code you’ll notice that most of the code is in a library, and the <code>main</code> function is part of a module that uses that library to build an executable.</p>
<p>By supplying <code>startGameLoop</code> the <code>main</code> function doesn’t need to know about anything <code>mtl</code> related. The executable doesn’t directly depend on the <code>mtl</code> package in that case. That doesn’t buy us much, but it’s nice to know that <code>mtl</code> is just an implementation detail from the perspective of the executable.</p>
<p>Our old <code>main</code> function looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  initialize [<span class="dt">InitEverything</span>]
  window <span class="ot">&lt;-</span> createWindow <span class="st">&quot;My SDL Application&quot;</span> defaultWindow
  r <span class="ot">&lt;-</span> createRenderer window (<span class="fu">-</span><span class="dv">1</span>) defaultRenderer
  gameLoop r defaultGameState</code></pre></div>
<p>and the new version looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  initialize [<span class="dt">InitEverything</span>]
  window <span class="ot">&lt;-</span> createWindow <span class="st">&quot;My SDL Application&quot;</span> defaultWindow
  r <span class="ot">&lt;-</span> createRenderer window (<span class="fu">-</span><span class="dv">1</span>) defaultRenderer
  startGameLoop r defaultGameState</code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>We’ve mostly swapped plumbing for typeclass constraints, although we’re getting into a better position to make further changes.</p>
<p><a href="./lens.html">Next</a> we’ll bring <code>lens</code> into the mix, and will also look at how mixing <code>mtl</code> and <code>lens</code> can provide some additional benefits.</p>]]></description>
    <pubDate>Mon, 14 Sep 2015 02:00:00 UT</pubDate>
    <guid>http://dlaing.org/falling-blocks/posts/part1/mtl.html</guid>
    <dc:creator>Dave Laing</dc:creator>
</item>
<item>
    <title>Adding `lens`</title>
    <link>http://dlaing.org/falling-blocks/posts/part1/lens.html</link>
    <description><![CDATA[<h1 id="introduction">Introduction</h1>
<p><a href="./mtl.html">Previously</a> we started using <code>mtl</code> as part of our running example.</p>
<p>In this post we’ll start using <code>lens</code>. We’ll be making fairly basic usage of <code>lens</code> for now, although we’ll also cover a nice trick combining <code>mtl</code> and <code>lens</code> that we’ll be using later on.</p>
<p>The code is available <a href="https://github.com/dalaing/falling-blocks/tree/master/code/part1/lens">here</a>.</p>
<h2 id="basic-lensing">Basic lensing</h2>
<p>Lenses are pretty handy. One of the ways we can view a lens is as a first-class combination of a getter and a setter that we can compose.</p>
<h3 id="updating-the-game-state">Updating the game state</h3>
<p>First we need some lenses. We’ll add them to our <code>GameState</code>, by changing from this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">GameState</span> <span class="fu">=</span> <span class="dt">GameState</span> {
<span class="ot">    backgroundColour ::</span> <span class="dt">Colour</span>
  ,<span class="ot"> hasQuit          ::</span> <span class="dt">Bool</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>to this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">GameState</span> <span class="fu">=</span> <span class="dt">GameState</span> {
    _<span class="ot">backgroundColour ::</span> <span class="dt">Colour</span>
  , _<span class="ot">hasQuit          ::</span> <span class="dt">Bool</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

makeLenses <span class="ch">&#39;&#39;</span><span class="dt">GameState</span></code></pre></div>
<p>We add the underscores so that the Template Haskell used inside <code>makeLenses</code> can work out which fields we want lenses for.</p>
<p>The result in this case will be two lenses:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">backgroundColour ::</span> <span class="dt">Lens&#39;</span> <span class="dt">GameState</span> <span class="dt">Colour</span></code></pre></div>
<p>and</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hasQuit ::</span> <span class="dt">Lens&#39;</span> <span class="dt">GameState</span> <span class="dt">Bool</span></code></pre></div>
<p>Lets put them to work.</p>
<h3 id="updating-the-event-handling">Updating the event handling</h3>
<p>The first thing we will do is update <code>handleEvent</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">handleEvent ::</span> <span class="dt">MonadState</span> <span class="dt">GameState</span> m
            <span class="ot">=&gt;</span> <span class="dt">AppEvent</span>
            <span class="ot">-&gt;</span> m ()
handleEvent <span class="dt">AppCycle</span> <span class="fu">=</span> modify <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs { backgroundColour <span class="fu">=</span> nextColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> gs }
handleEvent <span class="dt">AppQuit</span>  <span class="fu">=</span> modify <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs { hasQuit <span class="fu">=</span> <span class="dt">True</span> }
handleEvent _        <span class="fu">=</span> return ()</code></pre></div>
<p>We can use <code>.~</code> to set a value at the target of a lens, so we can replace</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gs { hasQuit <span class="fu">=</span> <span class="dt">True</span> }</code></pre></div>
<p>with</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gs <span class="fu">&amp;</span> hasQuit <span class="fu">.~</span> <span class="dt">True</span></code></pre></div>
<p>We can also use <code>%~</code> to apply a function to the target of a lens, so we also replace</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gs { backgroundColour <span class="fu">=</span> nextColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> gs }</code></pre></div>
<p>with</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gs <span class="fu">&amp;</span> backgroundColour <span class="fu">%~</span> nextColour</code></pre></div>
<p>This leaves us with:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">handleEvent ::</span> <span class="dt">MonadState</span> <span class="dt">GameState</span> m
            <span class="ot">=&gt;</span> <span class="dt">AppEvent</span>
            <span class="ot">-&gt;</span> m ()
handleEvent <span class="dt">AppCycle</span> <span class="fu">=</span> modify <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs <span class="fu">&amp;</span> backgroundColour <span class="fu">%~</span> nextColour
handleEvent <span class="dt">AppQuit</span>  <span class="fu">=</span> modify <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs <span class="fu">&amp;</span> hasQuit <span class="fu">.~</span> <span class="dt">True</span>
handleEvent _        <span class="fu">=</span> return ()</code></pre></div>
<p>There are also variants that work with the value carried around by the <code>MonadState</code>, which removes the need to call <code>modify</code>.</p>
<p>The convention is to change from <code>~</code> to <code>=</code> in the operators, so we have <code>.=</code> to set the value at the target of a lens and <code>%=</code> to apply a function to the value at the target of a lens.</p>
<p>This means we can replace</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">modify <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs <span class="fu">&amp;</span> hasQuit <span class="fu">.~</span> <span class="dt">True</span></code></pre></div>
<p>with</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">hasQuit <span class="fu">.=</span> <span class="dt">True</span></code></pre></div>
<p>and</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">modify <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs <span class="fu">&amp;</span> backgroundColour <span class="fu">%~</span> nextColour</code></pre></div>
<p>with</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">backgroundColour <span class="fu">%=</span> nextColour</code></pre></div>
<p>Our final version is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">handleEvent ::</span> <span class="dt">MonadState</span> <span class="dt">GameState</span> m
            <span class="ot">=&gt;</span> <span class="dt">AppEvent</span>
            <span class="ot">-&gt;</span> m ()
handleEvent <span class="dt">AppCycle</span> <span class="fu">=</span> backgroundColour <span class="fu">%=</span> nextColour
handleEvent <span class="dt">AppQuit</span>  <span class="fu">=</span> hasQuit <span class="fu">.=</span> <span class="dt">True</span>
handleEvent _        <span class="fu">=</span> return ()</code></pre></div>
<h3 id="updating-the-rendering">Updating the rendering</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
           <span class="ot">=&gt;</span> m ()
background <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> ask
  c <span class="ot">&lt;-</span> gets <span class="fu">$</span> toSDLColour <span class="fu">.</span> backgroundColour
  liftIO <span class="fu">$</span> <span class="kw">do</span>
    rendererDrawColor r <span class="fu">$=</span> c
    clear r</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
           <span class="ot">=&gt;</span> m ()
background <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> ask
  c <span class="ot">&lt;-</span> gets <span class="fu">$</span> toSDLColour <span class="fu">.</span> (<span class="fu">^.</span> backgroundColour)
  liftIO <span class="fu">$</span> <span class="kw">do</span>
    rendererDrawColor r <span class="fu">$=</span> c
    clear r</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
           <span class="ot">=&gt;</span> m ()
background <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> ask
  c <span class="ot">&lt;-</span> gets <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs <span class="fu">^.</span> backgroundColour <span class="fu">.</span> to toSDLColour
  liftIO <span class="fu">$</span> <span class="kw">do</span>
    rendererDrawColor r <span class="fu">$=</span> c
    clear r</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sdlBackgroundColour ::</span> <span class="dt">Lens&#39;</span> <span class="dt">GameState</span> (<span class="dt">V4</span> <span class="dt">Word8</span>)
sdlBackgroundColour <span class="fu">=</span> backgroundColour <span class="fu">.</span> to toSDLColour

<span class="ot">background ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
           <span class="ot">=&gt;</span> m ()
background <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> ask
  c <span class="ot">&lt;-</span> gets <span class="fu">$</span> \gs <span class="ot">-&gt;</span> gs <span class="fu">^.</span> sdlBackgroundColour
  liftIO <span class="fu">$</span> <span class="kw">do</span>
    rendererDrawColor r <span class="fu">$=</span> c
    clear r</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sdlBackgroundColour ::</span> <span class="dt">Lens&#39;</span> <span class="dt">GameState</span> (<span class="dt">V4</span> <span class="dt">Word8</span>)
sdlBackgroundColour <span class="fu">=</span> backgroundColour <span class="fu">.</span> to toSDLColour

<span class="ot">background ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
           <span class="ot">=&gt;</span> m ()
background <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> ask
  c <span class="ot">&lt;-</span> use sdlBackgroundColour
  liftIO <span class="fu">$</span> <span class="kw">do</span>
    rendererDrawColor r <span class="fu">$=</span> c
    clear r</code></pre></div>
<h3 id="updating-the-main-loop">Updating the main loop</h3>
<p>The change to the game loop is just a matter of swapping from <code>gets hasQuit</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameLoop ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
         <span class="ot">=&gt;</span> m ()
gameLoop <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- render the game</span>
  render
  <span class="co">-- update the GameState based on the events</span>
  doEvents
  <span class="co">-- check to see if the user has quit</span>
  q <span class="ot">&lt;-</span> gets hasQuit
  <span class="co">-- if not, keep going</span>
  unless q gameLoop</code></pre></div>
<p>to <code>use hasQuit</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameLoop ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
         <span class="ot">=&gt;</span> m ()
gameLoop <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- render the game</span>
  render
  <span class="co">-- update the GameState based on the events</span>
  doEvents
  <span class="co">-- check to see if the user has quit</span>
  q <span class="ot">&lt;-</span> use hasQuit
  <span class="co">-- if not, keep going</span>
  unless q gameLoop</code></pre></div>
<p>and we’re done.</p>
<h2 id="lensing-with-class">Lensing with class</h2>
<h3 id="preparing-for-more-configuration">Preparing for more configuration</h3>
<p>We’re about to get some more data that we’ll be passing around with our <code>MonadReader</code>, so we’re going to create a <code>Config</code> type to carry that around:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Config</span> {
    _<span class="ot">renderer ::</span> <span class="dt">Renderer</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

makeClassy <span class="ch">&#39;&#39;</span><span class="dt">Config</span></code></pre></div>
<p>The use of <code>makeClassy</code> is new here.</p>
<p>It sets up:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">HasConfig</span> a <span class="kw">where</span>
<span class="ot">  config ::</span> <span class="dt">Lens&#39;</span> a <span class="dt">Config</span>
<span class="ot">  renderer ::</span> <span class="dt">Lens&#39;</span> a <span class="dt">Renderer</span>

<span class="kw">instance</span> <span class="dt">HasConfig</span> <span class="dt">Config</span> <span class="kw">where</span>
  config <span class="fu">=</span> id</code></pre></div>
<p>We also add a helper to create <code>Config</code> values:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkConfig ::</span> <span class="dt">Renderer</span> <span class="ot">-&gt;</span> <span class="dt">Config</span>
mkConfig <span class="fu">=</span> <span class="dt">Config</span></code></pre></div>
<h3 id="changing-the-rendering">Changing the rendering</h3>
<p>Most of the effects of this change occur to the rendering functions.</p>
<p>We have to change the constraint from <code>MonadReader Renderer m</code> to the pair of constraints <code>(HasConfig c, MonadReader c m)</code>. We also have to change the use of <code>ask</code> - which gets hold of the <code>Renderer</code> to <code>view renderer</code>.</p>
<p>The <code>view</code> function allows us to read from the target of a lens, and it works with <code>MonadReader</code> out of the box.</p>
<p>The change for the <code>background</code> function is from:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
           <span class="ot">=&gt;</span> m ()
background <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> ask
  c <span class="ot">&lt;-</span> use <span class="fu">$</span> backgroundColour <span class="fu">.</span> to toSDLColour
  liftIO <span class="fu">$</span> <span class="kw">do</span>
    rendererDrawColor r <span class="fu">$=</span> c
    clear r</code></pre></div>
<p>to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> (<span class="dt">HasConfig</span> c, <span class="dt">MonadReader</span> c m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
           <span class="ot">=&gt;</span> m ()
background <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> view renderer
  c <span class="ot">&lt;-</span> use <span class="fu">$</span> backgroundColour <span class="fu">.</span> to toSDLColour
  liftIO <span class="fu">$</span> <span class="kw">do</span>
    rendererDrawColor r <span class="fu">$=</span> c
    clear r</code></pre></div>
<p>We also make the same change to <code>render</code>.</p>
<h3 id="changing-the-main-loop">Changing the main loop</h3>
<p>The main loop gets a similar change to the contraint, where:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameLoop ::</span> (<span class="dt">MonadReader</span> <span class="dt">Renderer</span> m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
         <span class="ot">=&gt;</span> m ()</code></pre></div>
<p>becomes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gameLoop ::</span> (<span class="dt">HasConfig</span> c, <span class="dt">MonadReader</span> c m, <span class="dt">MonadState</span> <span class="dt">GameState</span> m, <span class="dt">MonadIO</span> m)
         <span class="ot">=&gt;</span> m ()</code></pre></div>
<p>We also update our helper from:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">startGameLoop ::</span> <span class="dt">Renderer</span> <span class="ot">-&gt;</span> <span class="dt">GameState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
startGameLoop r <span class="fu">=</span> evalStateT (runReaderT gameLoop r)</code></pre></div>
<p>to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">startGameLoop ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">GameState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
startGameLoop c <span class="fu">=</span> evalStateT (runReaderT gameLoop c)</code></pre></div>
<p>This results in a flow on change to <code>main</code>, from:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  initialize [<span class="dt">InitEverything</span>]
  window <span class="ot">&lt;-</span> createWindow <span class="st">&quot;My SDL Application&quot;</span> defaultWindow
  r <span class="ot">&lt;-</span> createRenderer window (<span class="fu">-</span><span class="dv">1</span>) defaultRenderer
  startGameLoop r defaultGameState</code></pre></div>
<p>to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  initialize [<span class="dt">InitEverything</span>]
  window <span class="ot">&lt;-</span> createWindow <span class="st">&quot;My SDL Application&quot;</span> defaultWindow
  r <span class="ot">&lt;-</span> createRenderer window (<span class="fu">-</span><span class="dv">1</span>) defaultRenderer
  startGameLoop (mkConfig r) defaultGameState</code></pre></div>
<h3 id="where-classy-wins">Where classy wins</h3>
<p>The wins really turn up when we start nesting data more.</p>
<p>Imagine if we expanded the rendering information in the <code>Config</code>, creating a <code>RendererConfig</code> type with classy lenses set up.</p>
<p>We could then create:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">HasRendererConfig</span> <span class="dt">Config</span> <span class="kw">where</span>
  rendererConfig <span class="fu">=</span> renderer</code></pre></div>
<p>Now we can work with <code>MonadReader Config m</code>, but functions that only need access to the <code>RendererConfig</code> can use <code>(HasRendererConfig r, MonadReader r m)</code> as the context and still work with <code>MonadReader Config m</code>.</p>
<p>This is another case where we can make things easier to reason about and easier to refactor by limiting the amount of context that a function gets to the minimum that it needs.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Now we’ve got lenses in our code. It looks like small wins so far, but they’ll add up as things get more complex.</p>
<p><a href="./timer.html">Next</a> we’ll drive the updates using a timer, and will introduce STM along the way.</p>]]></description>
    <pubDate>Mon, 14 Sep 2015 02:00:00 UT</pubDate>
    <guid>http://dlaing.org/falling-blocks/posts/part1/lens.html</guid>
    <dc:creator>Dave Laing</dc:creator>
</item>
<item>
    <title>Expanding on the example</title>
    <link>http://dlaing.org/falling-blocks/posts/part1/cycle.html</link>
    <description><![CDATA[<h1 id="introduction">Introduction</h1>
<p><a href="./refactor.html">Previously</a> we took the example from <code>sdl2</code> and refactored it somewhat.</p>
<p>In this post we’ll add some additional functionality, in order to help motivate and explain some of the changes that will be made in the next few posts.</p>
<p>The change is straightforward: instead of having a fixed background colour, we’ll now have a background colour that gets cycled whenever the user presses the space key.</p>
<p>The code is available <a href="https://github.com/dalaing/falling-blocks/tree/master/code/part1/cycle">here</a>.</p>
<h1 id="the-changes">The changes</h1>
<h2 id="modelling-our-colours">Modelling our colours</h2>
<p>We’re going to add our own colour type, for reasons that will become apparent later.</p>
<p>For now, we’ll just have three colours:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Colour</span> <span class="fu">=</span>
    <span class="dt">Red</span>
  <span class="fu">|</span> <span class="dt">Green</span>
  <span class="fu">|</span> <span class="dt">Blue</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>We want to be able to cycle through them, so we define a function for that:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nextColour ::</span> <span class="dt">Colour</span>
           <span class="ot">-&gt;</span> <span class="dt">Colour</span>
nextColour <span class="dt">Red</span>   <span class="fu">=</span> <span class="dt">Green</span>
nextColour <span class="dt">Green</span> <span class="fu">=</span> <span class="dt">Blue</span>
nextColour <span class="dt">Blue</span>  <span class="fu">=</span> <span class="dt">Red</span></code></pre></div>
<p>Eventually we’ll need to be able to convert from our abstract representation of colour to the representation that SDL works with:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toSDLColour ::</span> <span class="dt">Colour</span>
            <span class="ot">-&gt;</span> <span class="dt">V4</span> <span class="dt">Word8</span>
toSDLColour <span class="dt">Red</span>   <span class="fu">=</span> <span class="dt">V4</span> <span class="dv">255</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">255</span>
toSDLColour <span class="dt">Green</span> <span class="fu">=</span> <span class="dt">V4</span> <span class="dv">0</span> <span class="dv">255</span> <span class="dv">0</span> <span class="dv">255</span>
toSDLColour <span class="dt">Blue</span>  <span class="fu">=</span> <span class="dt">V4</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">255</span> <span class="dv">255</span></code></pre></div>
<h2 id="updating-the-game-state">Updating the game state</h2>
<p>We need to add the background colour to our game state:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">GameState</span> <span class="fu">=</span> <span class="dt">GameState</span> {
<span class="ot">    backgroundColour ::</span> <span class="dt">Colour</span>
  ,<span class="ot"> hasQuit          ::</span> <span class="dt">Bool</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>The default game state gets updated to reflect this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">defaultGameState ::</span> <span class="dt">GameState</span>
defaultGameState <span class="fu">=</span> <span class="dt">GameState</span> <span class="dt">Blue</span> <span class="dt">False</span></code></pre></div>
<h2 id="updating-the-event-handling">Updating the event handling</h2>
<p>We’ll add a new event that indicates that the background colour should be cycled:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AppEvent</span> <span class="fu">=</span>
    <span class="dt">AppRender</span>
  <span class="fu">|</span> <span class="dt">AppCycle</span>
  <span class="fu">|</span> <span class="dt">AppQuit</span>
  <span class="fu">|</span> <span class="dt">AppOther</span> <span class="dt">Event</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>This event gets triggered when the user presses the space key:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toAppEvent ::</span> <span class="dt">Event</span>
           <span class="ot">-&gt;</span> <span class="dt">AppEvent</span>
toAppEvent event <span class="fu">=</span>
  <span class="kw">case</span> eventPayload event <span class="kw">of</span>
    <span class="dt">KeyboardEvent</span> keyboardEvent <span class="ot">-&gt;</span>
      <span class="kw">if</span> keyboardEventKeyMotion keyboardEvent <span class="fu">==</span> <span class="dt">Pressed</span>
      <span class="kw">then</span>
        <span class="kw">case</span> keysymKeycode (keyboardEventKeysym keyboardEvent) <span class="kw">of</span>
          <span class="dt">KeycodeSpace</span> <span class="ot">-&gt;</span> <span class="dt">AppCycle</span>
          <span class="dt">KeycodeQ</span>     <span class="ot">-&gt;</span> <span class="dt">AppQuit</span>
          _            <span class="ot">-&gt;</span> <span class="dt">AppOther</span> event
      <span class="kw">else</span>
        <span class="dt">AppOther</span> event
    _ <span class="ot">-&gt;</span> <span class="dt">AppOther</span> event</code></pre></div>
<h2 id="updating-the-rendering">Updating the rendering</h2>
<p>Unsurprisingly, we now need to have access to the background colour while rendering the background. We also have to convert it from our abstract <code>Colour</code> type to something SDL can deal with, using <code>toSDLColour</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">background ::</span> <span class="dt">Renderer</span>
           <span class="ot">-&gt;</span> <span class="dt">GameState</span>
           <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
background r s <span class="fu">=</span> <span class="kw">do</span>
  rendererDrawColor r <span class="fu">$=</span> (toSDLColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> s)
  clear r</code></pre></div>
<p>The <code>render</code> function needs to receive the <code>GameState</code> as an argument, so that it can pass the state along to any other rendering functions which need it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">render ::</span> <span class="dt">Renderer</span>
       <span class="ot">-&gt;</span> <span class="dt">GameState</span>
       <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
render r s <span class="fu">=</span> <span class="kw">do</span>
  background r s
  present r</code></pre></div>
<h2 id="updating-the-main-loop">Updating the main loop</h2>
<p>We now need to add a case in <code>gameStep</code> to handle the <code>AppCycle</code> event. To do this we take the old background colour, apply the <code>nextColour</code> function to it, and use the result as the new background colour:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gameStep _ <span class="dt">AppCycle</span> gs <span class="fu">=</span> 
  return <span class="fu">$</span> gs { backgroundColour <span class="fu">=</span> nextColour <span class="fu">.</span> backgroundColour <span class="fu">$</span> gs }</code></pre></div>
<p>The only other change we have to make is to pass the <code>GameState</code> to the <code>render</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gameStep r <span class="dt">AppRender</span> gs <span class="fu">=</span> <span class="kw">do</span>
  render r gs
  return gs</code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>That was a fairly small change in functionality, and we’re in a much better place for motivating the changes that are coming up.</p>
<p><a href="./mtl.html">Next</a> we’ll add monad transformers into the picture.</p>]]></description>
    <pubDate>Mon, 14 Sep 2015 02:00:00 UT</pubDate>
    <guid>http://dlaing.org/falling-blocks/posts/part1/cycle.html</guid>
    <dc:creator>Dave Laing</dc:creator>
</item>

    </channel>
</rss>
